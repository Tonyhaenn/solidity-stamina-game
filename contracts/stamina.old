//SPDX-License-Identifier: UNLICENSED
/*
Trying to avoid need to loop over every players balance
1) Keep track of total player value + all player values every time stake?
2) Since we know the end date of the contract, 24H prior to end, start flagging players that play in that window, and therefore will get their entire stake back plus share of broken?
3) hmm. still need a separate TX with loop to identify broken players?
*/
pragma solidity ^0.6.0;
pragma experimental ABIEncoderV2;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/math/SafeMath.sol";

contract Stamina is Ownable {
  using SafeMath for uint256;

  uint256 public minStake;
  uint256 public roundLength;
  uint256 public roundEnd;
  uint256 public activeRound;

  struct Stake {
    uint256 amount;
    uint256 timestamp;
    uint256 roundTotalAmount;
  }

  event StakeEvent (
    address indexed player,
    uint256 indexed round,
    uint256 amount
  );

  event LogEvent (
    bytes32 txt,
    uint256 lineNumber
  );
  //////// NEW DATA STRUCTURES /////////////
  /*
  * Keep track of stakes, by round and player
  * stakeStorage = roundNum: {
    playerAddress: {
      StakeNum: Stake
    }
  }
  
  Keep track of how many stakes a player has played for a given round
  playerStakeCount = roundNum: { playerAddress: stakeCount }

  Need something to keep track of total stake balances as game progresses
  Each round has N days (based on round length)
  For each round, day, store the total value of all stakes added
  As player stakes, move value from Day1 to Day 2 (two operations, decrement total player stake from prior day and add to current day)
  
  roundNum: { day: value }

  */
  //////// OLD DATA STRUCTURE BELOW ////////
  /*
  roundNum: {
    playerAddress: [Stake, Stake, Stake]
  }
  This could be replaced with a mapping, where the id is is the stake number
  roundNum: { playerAddress: {stakeNumber => Stake} }
  Would require each Stake to carry forward the valid balance from the prior stake
  */
  mapping(uint256 => mapping(address => Stake[])) private playerRound;
  /*
  round: countOfPlayers
  */
  mapping(uint256 => uint256) private roundPlayerCount;

  /*
  roundNum: {
    playerAddress: countOfStake
  }
  */
  mapping(uint256 => mapping(address => uint256)) private playerRoundStakeCount;
  /**
   * @notice Constructor for contract that sets base values for round length, and 
  */

  constructor() public {
    roundLength = 14 * 1 days;
    roundEnd = now + roundLength;
    activeRound = 1;
    minStake = 16 finney;
  }

  /**
   * @notice Determines if round is ended. Called during stake.
   */
  function endRound() private {
    uint256 currentTime = block.timestamp;
    if (currentTime > roundEnd) {
      activeRound += 1;
      roundEnd = now + roundLength;
      return;
    } 
    return;
  }
  /**
   * @notice Getter for player round data.
   * @param roundNum integer round number
   * @param player player address
   * @return array of stakes 
   */
  function getPlayerRoundStakes(uint256 roundNum, address player) public view 
  returns (Stake[] memory)
  {
    require(roundNum >0, "Round must be positive integer");
    return playerRound[roundNum][player];
  }
  /**
   *  @notice Primary entry point for playing the game. Checks for prior stake and carries forward value if time diff <24H
   */
  function stake() public payable {
    /* DEV Notes
    Tried to implement below. Blew up gas cost, and apparently has a bug.

    Each time a player stakes
    1. Fetch the last stake
    2. Calculate whether the last stake is valid
    -- Valid if datediff <24H
    3. Add prior stake balance to current stake balance
    */
    require(msg.value >= minStake, "You must stake at least the minimum.");

    endRound();

    address player;
    bool playerValidStake;
    uint256 stakeAmount;
    uint256 playerTotalStakes;
    uint256 playerRoundTotalValue;
    Stake storage priorStake;

    player = msg.sender;
    stakeAmount = msg.value;
    
    playerTotalStakes = playerRoundStakeCount[activeRound][player];
    emit LogEvent("playerTotalStakes", playerTotalStakes);
    // The following line fails when the player stakes for the first time. No prior stake. 
    //priorStake = playerRound[activeRound][player][playerTotalStakes];
  /*
    
    //Validate stake
    playerValidStake = validateStakes(block.timestamp, priorStake.timestamp);

    //Figure out appropriate value
    if(playerValidStake) {
      playerRoundTotalValue = priorStake.roundTotalAmount + msg.value;
    } else {
      playerRoundTotalValue = msg.value;
    }

    //Push new stake
    playerRound[activeRound][player].push(Stake(stakeAmount, block.timestamp, playerRoundTotalValue) );

    //Increment Counters
      playerRoundStakeCount[activeRound][player] += 1;

    // Should only increment this if first stake for the player
    //roundPlayerCount[activeRound] += 1;
    emit StakeEvent(player, activeRound, stakeAmount);
    */
  }
  /** 
  * @notice Calculates a players winnings for a given round
  * @param roundNum round 
  * @param player player address
  */
  function playerRoundWinnings(uint256 roundNum, address player) public view {
    // -- Multiple functions?
    // Func 1
    // Get player stakes, determine if any are valid
    // If not, return 0
    //for (uint256 index = 0; index < array.length; index++) {
    //    const element = array[index];
    //}
    // Func 2
    // Determine how many stakes are valid given a set of stakes

    // func 3
    // Get all stakes and which sets are valid
    // Player valid stakes / all valid stakes
    // Return proportion * invalid stakes + player valid 
  }
  /**
   *  @notice Allows a player to withdraw winnings
   *  @param roundNum of round where winnings should be withdrawn
   */
  //function playerWithdraw(uint256 roundNum) public  {
  //  address playerAddress = msg.sender;
  //
  //}

  /**
   * @notice Determines if a stake is valid by comparing to newer stake timestamp. Difference must be less than 24H
   * @param currentStakeTimestamp stake to validate
   * @param priorStakeTimestamp prior stake when sorted timestamp descending (newest stake)
   */

  function validateStakes(uint256 currentStakeTimestamp, uint256  priorStakeTimestamp ) public view returns (bool){
    //If priorStake - currentStake < 24H then valid else not validnp
    // OR
    // If currentState - roundEnd < 24H
    uint256 stakeWindow = 24 * 60 * 60;
    
    bool currentStakeWithinRoundEnd = false;
    if(roundEnd - currentStakeTimestamp < stakeWindow) {
      currentStakeWithinRoundEnd = true;
    }

    bool currentStakeWithinPrior = false;
    if(currentStakeTimestamp - priorStakeTimestamp < stakeWindow){
      currentStakeWithinPrior = true;
    }

    return(currentStakeWithinRoundEnd || currentStakeWithinPrior);
  }
}